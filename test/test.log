

  Your Test Suite
    √ Test Case (961ms)
Server is listening on localhost:3000
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Users';

  User Interactions
    √ should toggle search form on search button click
Executing (default): CREATE TABLE IF NOT EXISTS `Users` (`user_id` INTEGER PRIMARY KEY AUTOINCREMENT, `password_text` VARCHAR(255) NOT NULL, `email` VARCHAR(255) NOT NULL, `login` VARCHAR(255) NOT NULL, `status_text` VARCHAR(255) NOT NULL);
    √ should toggle login form on login button click
    √ should close login form on close button click
    √ should add active class to header on scroll

  Swiper Initialization
    √ should initialize Swiper for books slider
    √ should initialize Swiper for featured slider
    √ should initialize Swiper for arrivals slider

  Routes
    √ should respond with 404 for undefined routes
    √ should respond with 302 for the root route
Not logged in
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Executing (default): PRAGMA INDEX_LIST(`Users`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Authors';
    √ should respond with 400 for the addBook route
Executing (default): CREATE TABLE IF NOT EXISTS `Authors` (`author_id` INTEGER PRIMARY KEY AUTOINCREMENT, `full_name` VARCHAR(255) NOT NULL);
    √ should respond with 404 for the book route
    √ should respond with 404 for the editBook route
Executing (default): SELECT count(*) AS `count` FROM `Genres` AS `Genres`;
Executing (default): PRAGMA INDEX_LIST(`Authors`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Books';
Executing (default): CREATE TABLE IF NOT EXISTS `Books` (`book_id` INTEGER PRIMARY KEY AUTOINCREMENT, `genre_id` INTEGER NOT NULL, `image_name` VARCHAR(255) NOT NULL, `author_id` INTEGER NOT NULL, `title` VARCHAR(255) NOT NULL, `price` DOUBLE PRECISION NOT NULL, `date` VARCHAR(255) NOT NULL, `publish_date` VARCHAR(255) NOT NULL, `description` TEXT);
Executing (default): PRAGMA INDEX_LIST(`Books`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Applications';
Executing (default): CREATE TABLE IF NOT EXISTS `Applications` (`application_id` INTEGER PRIMARY KEY AUTOINCREMENT, `cartCollection_id` INTEGER NOT NULL, `user_id` INTEGER NOT NULL, `status_text` VARCHAR(255) NOT NULL, `date` VARCHAR(255) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Applications`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='CartCollections';
Executing (default): CREATE TABLE IF NOT EXISTS `CartCollections` (`entry_id` INTEGER PRIMARY KEY AUTOINCREMENT, `cartCollection_id` INTEGER NOT NULL, `book_id` INTEGER NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`CartCollections`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Sales';
Executing (default): CREATE TABLE IF NOT EXISTS `Sales` (`sale_id` INTEGER PRIMARY KEY AUTOINCREMENT, `user_id` INTEGER NOT NULL, `application_id` INTEGER NOT NULL, `cartCollection_id` INTEGER NOT NULL, `date` VARCHAR(255) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Sales`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='BookTags';
Executing (default): CREATE TABLE IF NOT EXISTS `BookTags` (`entry_id` INTEGER PRIMARY KEY AUTOINCREMENT, `book_id` INTEGER NOT NULL, `tag_id` INTEGER NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`BookTags`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Tags';
Executing (default): CREATE TABLE IF NOT EXISTS `Tags` (`tag_id` INTEGER PRIMARY KEY AUTOINCREMENT, `tag_name` VARCHAR(255) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Tags`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Genres';
Executing (default): CREATE TABLE IF NOT EXISTS `Genres` (`genre_id` INTEGER PRIMARY KEY AUTOINCREMENT, `genre_name` VARCHAR(255) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Genres`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Reviews';
Executing (default): CREATE TABLE IF NOT EXISTS `Reviews` (`review_id` INTEGER PRIMARY KEY AUTOINCREMENT, `user_id` INTEGER NOT NULL, `book_id` INTEGER NOT NULL, `rating` INTEGER NOT NULL, `content` VARCHAR(255) NOT NULL, `date` VARCHAR(255) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Reviews`)
<ref *1> Sequelize {
  options: {
    dialect: 'sqlite',
    dialectModule: null,
    dialectModulePath: null,
    protocol: 'tcp',
    define: { timestamps: false },
    query: {},
    sync: {},
    timezone: '+00:00',
    standardConformingStrings: true,
    logging: [Function: log],
    omitNull: false,
    native: false,
    replication: false,
    ssl: undefined,
    pool: {},
    quoteIdentifiers: true,
    hooks: {},
    retry: { max: 5, match: [Array] },
    transactionType: 'DEFERRED',
    isolationLevel: null,
    databaseVersion: 0,
    typeValidation: false,
    benchmark: false,
    minifyAliases: false,
    logQueryParameters: false,
    attributeBehavior: 'throw',
    storage: 'bookStore.db'
  },
  config: {
    database: undefined,
    username: undefined,
    password: null,
    host: 'localhost',
    port: undefined,
    pool: {},
    protocol: 'tcp',
    native: false,
    ssl: undefined,
    replication: false,
    dialectModule: null,
    dialectModulePath: null,
    keepDefaultTimezone: undefined,
    dialectOptions: undefined
  },
  dialect: <ref *2> SqliteDialect {
    sequelize: [Circular *1],
    connectionManager: ConnectionManager {
      sequelize: [Circular *1],
      config: [Object],
      dialect: [Circular *2],
      versionPromise: null,
      dialectName: 'sqlite',
      pool: [Pool],
      connections: [Object],
      lib: [Object]
    },
    queryGenerator: SQLiteQueryGenerator {
      sequelize: [Circular *1],
      options: [Object],
      dialect: 'sqlite',
      _dialect: [Circular *2],
      _quoteIdentifier: [Function: quoteIdentifier],
      quoteIdentifier: [Function (anonymous)],
      OperatorMap: [Object],
      typeValidation: undefined
    },
    queryInterface: SQLiteQueryInterface {
      sequelize: [Circular *1],
      queryGenerator: [SQLiteQueryGenerator]
    }
  },
  queryInterface: SQLiteQueryInterface {
    sequelize: [Circular *1],
    queryGenerator: SQLiteQueryGenerator {
      sequelize: [Circular *1],
      options: [Object],
      dialect: 'sqlite',
      _dialect: [SqliteDialect],
      _quoteIdentifier: [Function: quoteIdentifier],
      quoteIdentifier: [Function (anonymous)],
      OperatorMap: [Object],
      typeValidation: undefined
    }
  },
  models: {
    Users: Users,
    Authors: Authors,
    Books: Books,
    Applications: Applications,
    CartCollections: CartCollections,
    Sales: Sales,
    BookTags: BookTags,
    Tags: Tags,
    Genres: Genres,
    Reviews: Reviews
  },
  modelManager: ModelManager {
    models: [
      Users,
      Authors,
      Books,
      Applications,
      CartCollections,
      Sales,
      BookTags,
      Tags,
      Genres,
      Reviews
    ],
    sequelize: [Circular *1]
  },
  connectionManager: <ref *3> ConnectionManager {
    sequelize: [Circular *1],
    config: {
      database: undefined,
      username: undefined,
      password: null,
      host: 'localhost',
      port: undefined,
      pool: [Object],
      protocol: 'tcp',
      native: false,
      ssl: undefined,
      replication: false,
      dialectModule: null,
      dialectModulePath: null,
      keepDefaultTimezone: undefined,
      dialectOptions: undefined
    },
    dialect: <ref *2> SqliteDialect {
      sequelize: [Circular *1],
      connectionManager: [Circular *3],
      queryGenerator: [SQLiteQueryGenerator],
      queryInterface: [SQLiteQueryInterface]
    },
    versionPromise: null,
    dialectName: 'sqlite',
    pool: Pool {
      log: false,
      idleTimeoutMillis: 10000,
      acquireTimeoutMillis: 60000,
      reapIntervalMillis: 1000,
      maxUsesPerResource: Infinity,
      _factory: [Object],
      _count: 0,
      _draining: false,
      _pendingAcquires: [],
      _inUseObjects: [],
      _availableObjects: [],
      _removeIdleScheduled: false
    },
    connections: { default: Database {} },
    lib: {
      Database: [Function: Database],
      Statement: [Function: Statement],
      Backup: [Function: Backup],
      OPEN_READONLY: 1,
      OPEN_READWRITE: 2,
      OPEN_CREATE: 4,
      OPEN_FULLMUTEX: 65536,
      OPEN_URI: 64,
      OPEN_SHAREDCACHE: 131072,
      OPEN_PRIVATECACHE: 262144,
      VERSION: '3.44.2',
      SOURCE_ID: '2023-11-24 11:41:44 ebead0e7230cd33bcec9f95d2183069565b9e709bf745c9b5db65cc0cbf92c0f',
      VERSION_NUMBER: 3044002,
      OK: 0,
      ERROR: 1,
      INTERNAL: 2,
      PERM: 3,
      ABORT: 4,
      BUSY: 5,
      LOCKED: 6,
      NOMEM: 7,
      READONLY: 8,
      INTERRUPT: 9,
      IOERR: 10,
      CORRUPT: 11,
      NOTFOUND: 12,
      FULL: 13,
      CANTOPEN: 14,
      PROTOCOL: 15,
      EMPTY: 16,
      SCHEMA: 17,
      TOOBIG: 18,
      CONSTRAINT: 19,
      MISMATCH: 20,
      MISUSE: 21,
      NOLFS: 22,
      AUTH: 23,
      FORMAT: 24,
      RANGE: 25,
      NOTADB: 26,
      LIMIT_LENGTH: 0,
      LIMIT_SQL_LENGTH: 1,
      LIMIT_COLUMN: 2,
      LIMIT_EXPR_DEPTH: 3,
      LIMIT_COMPOUND_SELECT: 4,
      LIMIT_VDBE_OP: 5,
      LIMIT_FUNCTION_ARG: 6,
      LIMIT_ATTACHED: 7,
      LIMIT_LIKE_PATTERN_LENGTH: 8,
      LIMIT_VARIABLE_NUMBER: 9,
      LIMIT_TRIGGER_DEPTH: 10,
      LIMIT_WORKER_THREADS: 11,
      path: 'D:\\Users\\Admin\\Downloads\\book-store-master (1)\\book-store\\node_modules\\sqlite3\\build\\Release\\node_sqlite3.node',
      cached: [Object],
      verbose: [Function (anonymous)]
    }
  }
}
    1) should respond with 200 for the genres route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the registration route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the shoppingCart route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the searchPage route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
    √ should respond with 400 for the orders route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
    √ should respond with 400 for the accepted_orders route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the wishList route
    √ should respond with 404 for the login route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the searchPage route
Executing (default): SELECT `user_id`, `password_text`, `email`, `login`, `status_text` FROM `Users` AS `Users` WHERE `Users`.`login` = 'Not logged in' LIMIT 1;
Not logged in
    √ should respond with 200 for the shoppingCart route
    GET /
      √ should redirect to /home

  Database Synchronization
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Users';
Executing (default): PRAGMA INDEX_LIST(`Users`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Authors';
Executing (default): PRAGMA INDEX_LIST(`Authors`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Books';
Executing (default): PRAGMA INDEX_LIST(`Books`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Applications';
Executing (default): PRAGMA INDEX_LIST(`Applications`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='CartCollections';
Executing (default): PRAGMA INDEX_LIST(`CartCollections`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Sales';
Executing (default): PRAGMA INDEX_LIST(`Sales`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='BookTags';
Executing (default): PRAGMA INDEX_LIST(`BookTags`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Tags';
Executing (default): PRAGMA INDEX_LIST(`Tags`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Genres';
Executing (default): PRAGMA INDEX_LIST(`Genres`)
Executing (default): SELECT name FROM sqlite_master WHERE type='table' AND name='Reviews';
Executing (default): PRAGMA INDEX_LIST(`Reviews`)
    √ Synchronize database

  Database Tests
Executing (default): INSERT INTO `Authors` (`author_id`,`full_name`) VALUES (NULL,$1);
    √ should create a new author (158ms)
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`genre_id` = 'Fantasy';
    √ should find books by genre
Executing (default): INSERT INTO `Books` (`book_id`,`genre_id`,`image_name`,`author_id`,`title`,`price`,`date`,`publish_date`,`description`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8);
    √ should create a new book (111ms)
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`title` = 'Test Book' LIMIT 1;
Executing (default): UPDATE `Books` SET `price`=$1 WHERE `book_id` = $2
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`title` = 'Test Book' LIMIT 1;
    √ should update book information (118ms)
Executing (default): INSERT INTO `Tags` (`tag_id`,`tag_name`) VALUES (NULL,$1);
    √ should create a new tag (113ms)
Executing (default): INSERT INTO `Genres` (`genre_id`,`genre_name`) VALUES (NULL,$1);
    √ should create a new genre (116ms)
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`genre_id` = 1;
    √ should retrieve all books of a specific genre
Executing (default): INSERT INTO `Genres` (`genre_id`,`genre_name`) VALUES (NULL,$1);
    √ should create a new genre (113ms)
Executing (default): SELECT `review_id`, `user_id`, `book_id`, `rating`, `content`, `date` FROM `Reviews` AS `Reviews` LIMIT 1;
    2) should update a review
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` LIMIT 1;
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`title` = 'Test Book' LIMIT 1;
    √ should find a book by title
Executing (default): SELECT count(*) AS `count` FROM `Books` AS `Books` WHERE `Books`.`genre_id` = 1;
    √ should count books in a genre
Executing (default): SELECT `author_id`, `full_name` FROM `Authors` AS `Authors` LIMIT 1;
Executing (default): SELECT `author_id`, `full_name` FROM `Authors` AS `Authors` WHERE `Authors`.`author_id` = 1;
    √ should find an author by ID
Executing (default): SELECT `author_id`, `full_name` FROM `Authors` AS `Authors` LIMIT 1;
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`author_id` = 1;
    √ should find books by author
Executing (default): INSERT INTO `Genres` (`genre_id`,`genre_name`) VALUES (NULL,$1);
    √ should create a new genre (105ms)
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` LIMIT 1;
Executing (default): INSERT INTO `Reviews` (`review_id`,`user_id`,`book_id`,`rating`,`content`,`date`) VALUES (NULL,$1,$2,$3,$4,$5);
    √ should create a new review for a book (117ms)
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` LIMIT 1;
Executing (default): SELECT `review_id`, `user_id`, `book_id`, `rating`, `content`, `date` FROM `Reviews` AS `Reviews` WHERE `Reviews`.`book_id` = 1;
    √ should find all reviews for a book
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` LIMIT 1;
Executing (default): UPDATE `Books` SET `genre_id`=$1 WHERE `book_id` = $2
Executing (default): SELECT `book_id`, `genre_id`, `image_name`, `author_id`, `title`, `price`, `date`, `publish_date`, `description` FROM `Books` AS `Books` WHERE `Books`.`book_id` = 1;
    √ should update a book genre (113ms)

  Login Form
    √ should log in when valid credentials are provided
    √ should show an error when invalid credentials are provided

Executing (default): SELECT max(`book_id`) AS `max` FROM `Books` AS `Books`;
Executing (default): DELETE FROM `Books` WHERE `book_id` = 1
Executing (default): SELECT max(`genre_id`) AS `max` FROM `Genres` AS `Genres`;
Executing (default): DELETE FROM `Genres` WHERE `genre_id` = 3
Executing (default): SELECT max(`genre_id`) AS `max` FROM `Genres` AS `Genres`;
Executing (default): DELETE FROM `Genres` WHERE `genre_id` = 2
Executing (default): SELECT max(`genre_id`) AS `max` FROM `Genres` AS `Genres`;
Executing (default): DELETE FROM `Genres` WHERE `genre_id` = 1
Executing (default): SELECT max(`author_id`) AS `max` FROM `Authors` AS `Authors`;
Executing (default): DELETE FROM `Authors` WHERE `author_id` = 1
Executing (default): SELECT max(`tag_id`) AS `max` FROM `Tags` AS `Tags`;
Executing (default): DELETE FROM `Tags` WHERE `tag_id` = 1
Executing (default): SELECT max(`review_id`) AS `max` FROM `Reviews` AS `Reviews`;
Executing (default): DELETE FROM `Reviews` WHERE `review_id` = 1

  42 passing (5s)
  2 failing

  1) Routes
       should respond with 200 for the genres route:
     Error: Timeout of 2000ms exceeded. For async tests and hooks, ensure "done()" is called; if returning a Promise, ensure it resolves. (D:\Users\Admin\Downloads\book-store-master (1)\book-store\test\server.test.js)
      at listOnTimeout (node:internal/timers:573:17)
      at process.processTimers (node:internal/timers:514:7)

  2) Database Tests
       should update a review:
     TypeError: this.skip is not a function
      at Context.<anonymous> (server.test.js:324:12)



